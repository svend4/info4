# –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∏ –ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥

**–î–∞—Ç–∞:** 2026-01-28
**–¢–∏–ø:** –°—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ + Unified Solution
**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ü–æ–ª–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
**–†–∞–∑–º–µ—Ä:** 797 —Å—Ç—Ä–æ–∫

---

## üìã –ù–∞–≤–∏–≥–∞—Ü–∏—è

- **‚Üê –û–±–∑–æ—Ä –≤—Å–µ—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:** [ARCHITECTURE_VARIANTS_OVERVIEW.md](ARCHITECTURE_VARIANTS_OVERVIEW.md)
- **‚Üê –í–∞—Ä–∏–∞–Ω—Ç 1:** [VARIANT_1_EXTERNAL_SERVICE.md](VARIANT_1_EXTERNAL_SERVICE.md)
- **‚Üê –í–∞—Ä–∏–∞–Ω—Ç 2:** [VARIANT_2_METHOD_DATABASE.md](VARIANT_2_METHOD_DATABASE.md)

---

# –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤

## –¢–∞–±–ª–∏—Ü–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è

| –ê—Å–ø–µ–∫—Ç | –í–∞—Ä–∏–∞–Ω—Ç 1: External Service | –í–∞—Ä–∏–∞–Ω—Ç 2: Method DB (Pseudo-RAG) |
|--------|----------------------------|----------------------------------|
| **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞** | –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å | –ë–∞–∑–∞ –º–µ—Ç–æ–¥–æ–≤ + Vector search |
| **–î–æ—Å—Ç—É–ø** | API endpoints | Semantic search |
| **–§–æ—Ä–º–∞—Ç** | YAML/JSON skills | Method schemas —Å embeddings |
| **Execution** | Service –≤—ã–ø–æ–ª–Ω—è–µ—Ç | AI –∫–æ–º–ø–æ–∑–∏—Ä—É–µ—Ç –∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç |
| **Platform** | –ù–µ–∑–∞–≤–∏—Å–∏–º—ã–π –æ—Ç LLM | –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω —Å AI |
| **–ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ** | Horizontal scaling | Vector DB scaling |
| **–ü–æ–∏—Å–∫** | By ID/category/tags | Semantic similarity |
| **–ö–æ–º–ø–æ–∑–∏—Ü–∏—è** | Manual chaining | AI-driven composition |
| **–ú–æ–Ω–µ—Ç–∏–∑–∞—Ü–∏—è** | API subscriptions | Skill marketplace |
| **–û–±—É—á–µ–Ω–∏–µ** | –ù–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è | AI —É—á–∏—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–µ—Ç–æ–¥—ã |
| **–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å** | API logs | Method pipeline visible |

## –°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã –∫–∞–∂–¥–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞

### –í–∞—Ä–∏–∞–Ω—Ç 1: External Service

**–õ—É—á—à–µ –∫–æ–≥–¥–∞:**
- ‚úÖ –ù—É–∂–Ω–∞ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ LLM
- ‚úÖ –í–∞–∂–Ω–∞ —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è monetization
- ‚úÖ –¢—Ä–µ–±—É–µ—Ç—Å—è strict security/compliance
- ‚úÖ –ù–µ–æ–±—Ö–æ–¥–∏–º –∫–æ–Ω—Ç—Ä–æ–ª—å execution
- ‚úÖ Enterprise –∫–ª–∏–µ–Ω—Ç—ã (SLA, support)

**–ü—Ä–∏–º–µ—Ä—ã use cases:**
- Enterprise platform –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–π
- API –¥–ª—è —Ä–∞–∑–Ω—ã—Ö LLM providers
- Regulated industries (—Ñ–∏–Ω–∞–Ω—Å—ã, –º–µ–¥–∏—Ü–∏–Ω–∞)
- Mission-critical applications

### –í–∞—Ä–∏–∞–Ω—Ç 2: Method DB (Pseudo-RAG)

**–õ—É—á—à–µ –∫–æ–≥–¥–∞:**
- ‚úÖ AI –¥–æ–ª–∂–µ–Ω —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ —Ä–µ—à–∞—Ç—å –∑–∞–¥–∞—á–∏
- ‚úÖ –ù—É–∂–Ω–∞ flexibility –≤ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –º–µ—Ç–æ–¥–æ–≤
- ‚úÖ –í–∞–∂–Ω–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ–¥ —Ä–∞–∑–Ω—ã–µ –∑–∞–¥–∞—á–∏
- ‚úÖ –¢—Ä–µ–±—É–µ—Ç—Å—è transparency (–≤–∏–¥–∏–º–æ—Å—Ç—å –ø—Ä–æ—Ü–µ—Å—Å–∞)
- ‚úÖ Continuous learning –æ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

**–ü—Ä–∏–º–µ—Ä—ã use cases:**
- AI agents —Å –∞–≤—Ç–æ–Ω–æ–º–Ω–æ—Å—Ç—å—é
- Creative problem solving
- Research & experimentation
- Personalized AI assistants

---

# –ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥

## –ö–æ–Ω—Ü–µ–ø—Ü–∏—è

**–û–±—ä–µ–¥–∏–Ω–∏—Ç—å –ª—É—á—à–µ–µ –∏–∑ –æ–±–æ–∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  AI Agent                        ‚îÇ
‚îÇ  ‚Ä¢ –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∑–∞–¥–∞—á—É                           ‚îÇ
‚îÇ  ‚Ä¢ –í—ã–±–∏—Ä–∞–µ—Ç –ø–æ–¥—Ö–æ–¥                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                        ‚îÇ
        ‚Üì                        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Method DB      ‚îÇ    ‚îÇ External Service ‚îÇ
‚îÇ  (Pseudo-RAG)    ‚îÇ    ‚îÇ   (API-based)    ‚îÇ
‚îÇ                  ‚îÇ    ‚îÇ                  ‚îÇ
‚îÇ ‚Ä¢ Semantic       ‚îÇ    ‚îÇ ‚Ä¢ Execution      ‚îÇ
‚îÇ   search         ‚îÇ    ‚îÇ ‚Ä¢ Monitoring     ‚îÇ
‚îÇ ‚Ä¢ Composition    ‚îÇ    ‚îÇ ‚Ä¢ Billing        ‚îÇ
‚îÇ ‚Ä¢ Planning       ‚îÇ    ‚îÇ ‚Ä¢ Security       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

```python
# hybrid_system.py - –ì–∏–±—Ä–∏–¥–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞

class HybridSkillsSystem:
    """–ì–∏–±—Ä–∏–¥–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ - Method DB + External Service"""

    def __init__(self):
        # Method DB –¥–ª—è –ø–æ–∏—Å–∫–∞ –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
        self.method_db = MethodQueryEngine()

        # External Service –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
        self.skills_service = SkillsServiceClient(
            api_url='https://api.skills.com',
            api_key=os.getenv('SKILLS_API_KEY')
        )

    async def solve_task(self, task: str):
        """
        Workflow:
        1. Method DB: –Ω–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –º–µ—Ç–æ–¥—ã
        2. Method DB: —Å–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –∫–æ–º–ø–æ–∑–∏—Ü–∏—é
        3. External Service: –≤—ã–ø–æ–ª–Ω–∏—Ç—å skills
        4. Return —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        """

        # 1. Search methods –≤ Method DB
        methods = self.method_db.search_methods(task, top_k=10)

        print(f"Found {len(methods)} methods via semantic search")

        # 2. Plan composition
        composition = self.method_db.suggest_method_composition(
            task,
            methods
        )

        print("Planned pipeline:")
        for step in composition['pipeline']:
            print(f"  {step['step']}. {step['method_id']}")

        # 3. Execute —á–µ—Ä–µ–∑ External Service
        results = []

        for step in composition['pipeline']:
            method_id = step['method_id']

            # –ü–æ–ª—É—á–∏—Ç—å input –¥–ª—è —ç—Ç–æ–≥–æ —à–∞–≥–∞
            step_input = results[-1]['result'] if results else task

            # Execute —á–µ—Ä–µ–∑ API
            result = await self.skills_service.execute_skill(
                skill_id=method_id,
                input_data={'input': step_input}
            )

            results.append({
                'step': step['step'],
                'method': method_id,
                'result': result['result']
            })

            print(f"‚úì Step {step['step']} completed")

        return {
            'final_result': results[-1]['result'],
            'steps': results
        }

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
hybrid = HybridSkillsSystem()

task = "Analyze customer feedback from CSV and create report"

# Method DB –Ω–∞–π–¥–µ—Ç –º–µ—Ç–æ–¥—ã
# External Service –≤—ã–ø–æ–ª–Ω–∏—Ç
result = await hybrid.solve_task(task)
```

## –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –≥–∏–±—Ä–∏–¥–∞

‚úÖ **Best of both worlds:**
- Method DB –¥–ª—è intelligent planning
- External Service –¥–ª—è robust execution

‚úÖ **Flexibility:**
- AI –º–æ–∂–µ—Ç –ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ª—é–±—ã–µ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
- Service –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

‚úÖ **Scalability:**
- Method DB: vector search scales well
- External Service: horizontal scaling

‚úÖ **Security:**
- Sandboxed execution –≤ service
- Rate limiting –∏ access control

‚úÖ **Monetization:**
- Method DB: –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –ø–æ–∏—Å–∫
- External Service: pay-per-execution

‚úÖ **Learning:**
- Method DB —É–ª—É—á—à–∞–µ—Ç—Å—è –æ—Ç feedback
- Service —Å–æ–±–∏—Ä–∞–µ—Ç usage analytics

---

# –î–µ—Ç–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –≥–∏–±—Ä–∏–¥–∞

## 1. Method DB —Å —Å—Å—ã–ª–∫–∞–º–∏ –Ω–∞ External Service

```yaml
# method_hybrid.yaml

apiVersion: methods.ai/v1
kind: Method
metadata:
  id: file-organizer-by-type
  name: File Organizer by Type

# Semantic info –¥–ª—è –ø–æ–∏—Å–∫–∞
semantics:
  purpose: Organize files by type
  capabilities: [...]
  suitable_for: [...]

# –°—Å—ã–ª–∫–∞ –Ω–∞ implementation –≤ External Service
implementation:
  type: external-service
  service_url: https://api.skills.com
  skill_id: file-organizer-by-type
  version: 2.1.0

# Authentication
execution:
  requires_auth: true
  rate_limit: 100/hour
  cost: 0.01  # USD per execution

# –ú–µ—Ç—Ä–∏–∫–∏ (—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É—é—Ç—Å—è –∏–∑ service)
metrics:
  usage_count: 1543  # from service
  success_rate: 0.94  # from service
  avg_duration_ms: 2341  # from service
```

## 2. External Service —Å Method DB –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π

```python
# skills_service_with_method_db.py

class SkillsServiceWithMethodDB:
    """External Service —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π Method DB"""

    def __init__(self):
        self.executor = SkillsExecutor()
        self.method_indexer = MethodIndexer()

    async def register_skill(self, skill: Dict):
        """
        –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è skill:
        1. –í External Service (–¥–ª—è execution)
        2. –í Method DB (–¥–ª—è search)
        """

        # 1. Register –≤ service
        service_id = await self.skills_registry.register(skill)

        # 2. Create method entry –¥–ª—è Method DB
        method = {
            'id': service_id,
            'name': skill['name'],
            'semantics': self.extract_semantics(skill),
            'implementation': {
                'type': 'external-service',
                'service_url': self.base_url,
                'skill_id': service_id
            },
            'metrics': {
                'usage_count': 0,
                'success_rate': 1.0,
                'avg_duration_ms': 0
            }
        }

        # 3. Index –≤ Method DB
        await self.method_indexer.index_method(method)

        return service_id

    async def execute_skill_and_update_method_db(
        self,
        skill_id: str,
        input_data: Dict
    ):
        """Execute skill –∏ –æ–±–Ω–æ–≤–∏—Ç—å –º–µ—Ç—Ä–∏–∫–∏ –≤ Method DB"""

        # Execute
        result = await self.executor.execute(skill_id, input_data)

        # Update metrics –≤ Method DB
        await self.method_indexer.update_metrics(
            method_id=skill_id,
            metrics={
                'usage_count': '+1',
                'success_rate': result['success'],
                'duration_ms': result['duration_ms']
            }
        )

        return result

    def extract_semantics(self, skill: Dict) -> Dict:
        """–ò–∑–≤–ª–µ—á—å semantic info –∏–∑ skill"""

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º LLM –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è semantics
        prompt = f"""
        From this skill definition, extract semantic information:

        Name: {skill['name']}
        Description: {skill['description']}
        Instructions: {skill['instructions'][:500]}
        Examples: {skill.get('examples', [])[:2]}

        Generate:
        1. Purpose (concise description)
        2. Capabilities (list)
        3. Suitable for (use cases)
        4. Prerequisites
        5. Expected outcomes

        Return JSON.
        """

        semantics = llm.generate(prompt)

        return semantics
```

## 3. AI Agent —Å –≥–∏–±—Ä–∏–¥–Ω—ã–º –¥–æ—Å—Ç—É–ø–æ–º

```python
# hybrid_ai_agent.py

class HybridAIAgent:
    """AI Agent –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–π Method DB + External Service"""

    def __init__(self):
        self.method_db = MethodQueryEngine()
        self.skills_service = SkillsServiceClient()
        self.cache = MethodCache()  # Local cache

    async def solve_task(
        self,
        task: str,
        execution_mode: str = 'auto'
    ):
        """
        Execution modes:
        - 'auto': AI –≤—ã–±–∏—Ä–∞–µ—Ç best approach
        - 'local': Execute –ª–æ–∫–∞–ª—å–Ω–æ –µ—Å–ª–∏ possible
        - 'service': Always use external service
        - 'hybrid': Plan locally, execute remotely
        """

        # 1. Find methods
        methods = await self.method_db.search_methods(task)

        # 2. Choose execution strategy
        if execution_mode == 'auto':
            strategy = self.choose_execution_strategy(methods, task)
        else:
            strategy = execution_mode

        # 3. Execute based on strategy
        if strategy == 'local':
            # Execute locally if methods are simple
            result = await self.execute_locally(methods, task)

        elif strategy == 'service':
            # Use external service
            result = await self.execute_via_service(methods, task)

        elif strategy == 'hybrid':
            # Plan locally, execute parts remotely
            result = await self.execute_hybrid(methods, task)

        return result

    def choose_execution_strategy(
        self,
        methods: List[Dict],
        task: str
    ) -> str:
        """AI –≤—ã–±–∏—Ä–∞–µ—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é"""

        # –§–∞–∫—Ç–æ—Ä—ã:
        # - –°–ª–æ–∂–Ω–æ—Å—Ç—å –º–µ—Ç–æ–¥–æ–≤
        # - –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ —Ä–µ—Å—É—Ä—Å–∞–º
        # - –°—Ç–æ–∏–º–æ—Å—Ç—å API calls
        # - Latency requirements
        # - Security/privacy

        complexity_score = self.calculate_complexity(methods)
        cost = self.estimate_cost(methods)
        latency_requirement = self.analyze_latency_needs(task)

        if complexity_score < 0.3 and cost < 0.10:
            return 'local'  # Simple and cheap - do locally

        elif complexity_score > 0.7 or cost > 1.00:
            return 'service'  # Complex or expensive - use service

        else:
            return 'hybrid'  # Mix of local and remote

    async def execute_hybrid(
        self,
        methods: List[Dict],
        task: str
    ):
        """Hybrid execution - some local, some remote"""

        composition = self.method_db.suggest_method_composition(
            task,
            methods
        )

        results = []

        for step in composition['pipeline']:
            method = next(
                m for m in methods
                if m['method']['id'] == step['method_id']
            )

            # Decide: local or remote?
            if self.can_execute_locally(method):
                # Execute locally
                result = await self.execute_method_locally(
                    method,
                    input_data=results[-1] if results else task
                )
            else:
                # Execute via service
                result = await self.skills_service.execute_skill(
                    skill_id=method['method']['id'],
                    input_data=results[-1] if results else task
                )

            results.append(result)

        return {
            'final_result': results[-1],
            'steps': results
        }

    def can_execute_locally(self, method: Dict) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –º–æ–∂–Ω–æ –ª–∏ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ"""

        # Check –µ—Å–ª–∏ –µ—Å—Ç—å local implementation
        impl = method['method'].get('implementation', {})

        if impl['type'] == 'claude-skill':
            # Claude skills –º–æ–∂–µ–º –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ
            return True

        elif impl['type'] == 'python' and self.has_dependencies(method):
            # Python scripts –µ—Å–ª–∏ –µ—Å—Ç—å dependencies
            return True

        elif impl['type'] == 'external-service':
            # –ù—É–∂–µ–Ω external service
            return False

        return False
```

## 4. –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è

```python
# method_cache.py

class MethodCache:
    """Cache –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ execution"""

    def __init__(self):
        self.cache = {}  # In-memory
        self.redis = redis.Redis()  # Persistent

    async def get(
        self,
        method_id: str,
        input_hash: str
    ) -> Optional[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å –∏–∑ cache"""

        cache_key = f"{method_id}:{input_hash}"

        # Try in-memory first
        if cache_key in self.cache:
            return self.cache[cache_key]

        # Try Redis
        cached = self.redis.get(cache_key)
        if cached:
            result = json.loads(cached)
            # Populate in-memory cache
            self.cache[cache_key] = result
            return result

        return None

    async def set(
        self,
        method_id: str,
        input_hash: str,
        result: Dict,
        ttl: int = 3600  # 1 hour
    ):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ cache"""

        cache_key = f"{method_id}:{input_hash}"

        # In-memory
        self.cache[cache_key] = result

        # Redis with TTL
        self.redis.setex(
            cache_key,
            ttl,
            json.dumps(result)
        )

    def hash_input(self, input_data: Any) -> str:
        """–°–æ–∑–¥–∞—Ç—å hash input –¥–ª—è caching"""
        import hashlib

        # Convert to canonical JSON
        canonical = json.dumps(input_data, sort_keys=True)

        # SHA256 hash
        hash_obj = hashlib.sha256(canonical.encode())

        return hash_obj.hexdigest()

# Usage in agent

class OptimizedHybridAgent(HybridAIAgent):
    """Agent —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""

    def __init__(self):
        super().__init__()
        self.cache = MethodCache()

    async def execute_method(
        self,
        method: Dict,
        input_data: Any
    ):
        """Execute —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""

        method_id = method['method']['id']
        input_hash = self.cache.hash_input(input_data)

        # Check cache
        cached = await self.cache.get(method_id, input_hash)

        if cached:
            print(f"‚úì Cache hit for {method['method']['name']}")
            return cached

        # Execute
        if self.can_execute_locally(method):
            result = await self.execute_method_locally(method, input_data)
        else:
            result = await self.skills_service.execute_skill(
                skill_id=method_id,
                input_data=input_data
            )

        # Cache result
        await self.cache.set(method_id, input_hash, result)

        return result
```

---

# –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

## –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –≤—ã–±–æ—Ä—É

### –í—ã–±—Ä–∞—Ç—å –í–∞—Ä–∏–∞–Ω—Ç 1 (External Service) –µ—Å–ª–∏:
- üéØ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: Platform-as-a-Service
- üéØ –ù—É–∂–Ω–∞ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç LLM
- üéØ Enterprise –∫–ª–∏–µ–Ω—Ç—ã
- üéØ Monetization —á–µ—Ä–µ–∑ API
- üéØ Strict security/compliance

### –í—ã–±—Ä–∞—Ç—å –í–∞—Ä–∏–∞–Ω—Ç 2 (Method DB) –µ—Å–ª–∏:
- üéØ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: AI-native solution
- üéØ –ù—É–∂–Ω–∞ flexibility –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
- üéØ Research & experimentation
- üéØ Personalized AI assistants
- üéØ Continuous learning

### –í—ã–±—Ä–∞—Ç—å –ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –µ—Å–ª–∏:
- üéØ –ù—É–∂–Ω—ã –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –æ–±–æ–∏—Ö
- üéØ –†–∞–∑–Ω—ã–µ use cases
- üéØ –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å + Flexibility
- üéØ –ì–æ—Ç–æ–≤—ã –∫ complexity —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

## Roadmap –≤–Ω–µ–¥—Ä–µ–Ω–∏—è

### Phase 1: MVP (2-3 –º–µ—Å—è—Ü–∞)
1. **–í–∞—Ä–∏–∞–Ω—Ç 2 (Method DB)** - –±—ã—Å—Ç—Ä–µ–µ –¥–ª—è MVP
   - Vector database setup
   - Basic method indexing
   - Semantic search
   - Simple AI integration

### Phase 2: Scale (3-6 –º–µ—Å—è—Ü–µ–≤)
2. **–í–∞—Ä–∏–∞–Ω—Ç 1 (External Service)**
   - API infrastructure
   - Skills executor
   - Monitoring & billing
   - Enterprise features

### Phase 3: Optimize (6-12 –º–µ—Å—è—Ü–µ–≤)
3. **–ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥**
   - Integrate Method DB + Service
   - Intelligent routing
   - Caching layer
   - Advanced features

## –ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞

**Method DB:**
- Search relevance > 85%
- Method composition quality > 80%
- User satisfaction > 4.5/5

**External Service:**
- Uptime > 99.9%
- API latency < 200ms (p95)
- Success rate > 98%

**–ì–∏–±—Ä–∏–¥–Ω—ã–π:**
- Cache hit rate > 60%
- Cost reduction > 40%
- Performance improvement > 30%

---

# –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä

## –ü–æ–ª–Ω—ã–π workflow –≥–∏–±—Ä–∏–¥–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã

```python
# complete_example.py - –ü–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä

import asyncio

async def main():
    # Initialize –≥–∏–±—Ä–∏–¥–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞
    system = HybridSkillsSystem(
        method_db_url='https://methods.ai',
        service_api_url='https://api.skills.com',
        api_key='your-api-key'
    )

    # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–∞–µ—Ç –∑–∞–¥–∞—á—É
    task = """
    I have a dataset of 10,000 customer reviews.
    I need to:
    1. Clean and preprocess the text
    2. Perform sentiment analysis
    3. Extract key topics
    4. Identify trends over time
    5. Generate executive summary report
    6. Create visualizations
    """

    print("üéØ Task:", task)
    print()

    # 1. Method DB: Semantic search
    print("üîç Searching Method DB for relevant methods...")
    methods = await system.method_db.search_methods(
        task_description=task,
        top_k=10
    )

    print(f"Found {len(methods)} relevant methods:")
    for m in methods[:5]:
        print(f"  ‚úì {m['method']['name']} (score: {m['final_score']:.2f})")
    print()

    # 2. Method DB: Plan composition
    print("üìê Planning pipeline...")
    composition = await system.method_db.suggest_method_composition(
        task=task,
        methods=methods
    )

    print("Planned pipeline:")
    for step in composition['pipeline']:
        print(f"  {step['step']}. {step['method_id']}")
    print()

    # 3. Hybrid execution
    print("‚öôÔ∏è  Executing hybrid pipeline...")

    results = []

    for step in composition['pipeline']:
        method_id = step['method_id']
        method = next(m for m in methods if m['method']['id'] == method_id)

        print(f"Step {step['step']}: {method['method']['name']}...")

        # Get input
        step_input = results[-1]['result'] if results else task

        # Choose execution: local or remote
        if system.can_execute_locally(method):
            print("  ‚Üí Executing locally")
            result = await system.execute_locally(method, step_input)
        else:
            print("  ‚Üí Executing via External Service")
            result = await system.execute_via_service(method, step_input)

        results.append({
            'step': step['step'],
            'method': method_id,
            'result': result,
            'execution': 'local' if system.can_execute_locally(method) else 'remote'
        })

        print(f"  ‚úì Completed in {result['duration_ms']}ms")
        print()

    # 4. Return final result
    print("‚úÖ Task completed!")
    print()
    print("Summary:")
    print(f"  Total steps: {len(results)}")
    print(f"  Local executions: {sum(1 for r in results if r['execution'] == 'local')}")
    print(f"  Remote executions: {sum(1 for r in results if r['execution'] == 'remote')}")
    print(f"  Total duration: {sum(r['result']['duration_ms'] for r in results)}ms")
    print()
    print("Final result:")
    print(results[-1]['result']['output'][:500] + "...")

if __name__ == '__main__':
    asyncio.run(main())

# Output:
# üéØ Task: I have a dataset of 10,000 customer reviews...
#
# üîç Searching Method DB for relevant methods...
# Found 10 relevant methods:
#   ‚úì Text Preprocessor (score: 0.92)
#   ‚úì Sentiment Analyzer (score: 0.89)
#   ‚úì Topic Extractor (score: 0.87)
#   ‚úì Trend Analyzer (score: 0.84)
#   ‚úì Report Generator (score: 0.81)
#
# üìê Planning pipeline...
# Planned pipeline:
#   1. text-preprocessor
#   2. sentiment-analyzer
#   3. topic-extractor
#   4. trend-analyzer
#   5. report-generator
#   6. visualization-creator
#
# ‚öôÔ∏è  Executing hybrid pipeline...
# Step 1: Text Preprocessor...
#   ‚Üí Executing via External Service
#   ‚úì Completed in 2341ms
#
# Step 2: Sentiment Analyzer...
#   ‚Üí Executing via External Service
#   ‚úì Completed in 5678ms
#
# Step 3: Topic Extractor...
#   ‚Üí Executing locally
#   ‚úì Completed in 1234ms
#
# [...]
#
# ‚úÖ Task completed!
#
# Summary:
#   Total steps: 6
#   Local executions: 2
#   Remote executions: 4
#   Total duration: 15432ms
```

---

**–î–æ–∫—É–º–µ–Ω—Ç —Å–æ–∑–¥–∞–Ω:** 2026-01-28
**–í–µ—Ä—Å–∏—è:** 1.0 Complete
**–û—Ö–≤–∞—Ç:** 2 –≤–∞—Ä–∏–∞–Ω—Ç–∞ + –≥–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥
**–°—Ç—Ä–∞–Ω–∏—Ü —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—è:** ~150

## –ö–ª—é—á–µ–≤—ã–µ –≤—ã–≤–æ–¥—ã

1. **–í–∞—Ä–∏–∞–Ω—Ç 1 (External Service)** - –æ—Ç–ª–∏—á–Ω—ã–π –¥–ª—è enterprise –∏ monetization
2. **–í–∞—Ä–∏–∞–Ω—Ç 2 (Method DB / Pseudo-RAG)** - —Ä–µ–≤–æ–ª—é—Ü–∏–æ–Ω–Ω—ã–π –¥–ª—è AI-native workflows
3. **–ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥** - best of both worlds, —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –¥–ª—è production

–û–±–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –∂–∏–∑–Ω–µ—Å–ø–æ—Å–æ–±–Ω—ã –∏ –º–æ–≥—É—Ç —Å–æ—Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å! üöÄ

